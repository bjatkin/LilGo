package main

import (
	"fmt"
	"os"
	"strconv"
	"strings"
)

// this block defines all the token types for the language
type LBraceTok string
type RBraceTok string
type LParenTok string
type RParenTok string
type AddTok string
type SubTok string
type LessTok string
type GreatTok string
type EqualTok string
type NotEqualTok string
type SemicolonTok string
type NewlineTok string
type AssignTok string
type IfTok string
type ElseTok string
type ForTok string
type VarTok string
type Uint8Tok string

var letters, numbers = "abcdefghijklmnopqrstuvwxyz", "0123456789"
var KnownTokens = []any{
	NewlineTok("\n"), LBraceTok("{\n"), RBraceTok("}"), LParenTok("("), RParenTok(")"), AddTok("+"), SubTok("-"), LessTok("<"),
	GreatTok(">"), AssignTok("="), EqualTok("=="), NotEqualTok("!="), SemicolonTok(";"), IfTok("if"), ElseTok("else"), ForTok("for"),
}

// must helps make error handling more efficient/ take up less lines, it does make errors harder to understand though
func must[T any](ret T, err error) T {
	if err != nil {
		panic(err)
	}
	return ret
}

func main() {
	file := must(os.ReadFile(os.Args[2]))
	switch os.Args[1] {
	case "build":
		src = append(file, '\n')
		program := []any{}
		for nextToken(false) != nil {
			program = append(program, stmt())
		}
		must(0, os.WriteFile(strings.TrimSuffix(os.Args[2], ".lil"), append(compile(program), HaltOp), 0o0655))
	case "run":
		globals := run(file)
		for i, name := range letters {
			if globals[i] == 0 {
				continue
			}
			fmt.Printf("%s = %d\n", string(name), globals[i])
		}
	}
}

// === Lexer ===

// src and srcIdx are used to lex the source code along with the parser
var src, srcIdx = []byte{}, 0

// nextToken returns the next token in the source code. If consume is false, it will not
// progress to the next token
func nextToken(consume bool) any {
	// skip white space
	for srcIdx < len(src) && (src[srcIdx] == ' ' || src[srcIdx] == '\t') {
		srcIdx++
	}

	// check for and skip comment lines
	if srcIdx < len(src) && strings.HasPrefix(string(src[srcIdx:]), "//") {
		for srcIdx < len(src) && src[srcIdx] != '\n' {
			srcIdx++
		}
	}

	// return nil if we're out of tokens
	if srcIdx >= len(src) {
		return nil
	}

	var token any
	switch {
	// this handles numeric tokens (e.g. 1, 234, 5), note that while we can parse numbers greater than 255
	// those literals will cause issues later on in the code
	case strings.Contains(numbers, string(src[srcIdx])):
		intValue := ""
		for i := srcIdx; i < len(src); i++ {
			if !strings.Contains(numbers, string(src[i])) {
				break
			}
			intValue += string(src[i])
		}
		token = Uint8Tok(intValue)
	// this handles variable names which must be a single letter a-z
	case strings.Contains(letters, string(src[srcIdx])):
		token = VarTok(string(src[srcIdx]))
	}

	// check all the known tokens likes keywords and symbols
	for _, known := range KnownTokens {
		if strings.HasPrefix(string(src[srcIdx:]), fmt.Sprint(known)) {
			token = known
		}
	}

	// if we're just peeking we need to skip taking the tokens
	if consume {
		srcIdx += len(fmt.Sprint(token))
	}
	return token
}

// === Parser ===

// Node is the base type for all the nodes in the AST generated by the parser
type Node[T any] struct {
	V   T
	sub []any
}

// This block defines all the Node types for the AST
type If Node[string]
type For Node[string]
type Bool Node[bool]
type Var Node[string]
type Uint8 Node[uint8]
type Less Node[string]
type Great Node[string]
type Equal Node[string]
type NotEqual Node[string]
type Add Node[string]
type Sub Node[string]
type Assign Node[string]
type None Node[struct{}]

// stmt parses tokens into statement trees
func stmt() any {
	switch v := nextToken(true).(type) {
	case NewlineTok:
		return None{}
	case IfTok:
		test, body := expr(), blockStmt()
		if _, ok := nextToken(true).(ElseTok); ok {
			defer func() { _ = nextToken(true).(NewlineTok) }()
			return If{"if", []any{test, body, blockStmt()}}
		}
		return If{"if", []any{test, body}}
	case ForTok:
		var initial, test, check any
		if _, ok := nextToken(false).(SemicolonTok); !ok {
			initial = varStmt(nextToken(true))
		}
		_ = nextToken(true).(SemicolonTok)
		// the test expression is required unlike the other two var statements because
		// there is no break keyword in the language so there is no other way to terminate
		// for loops
		test = expr()
		_ = nextToken(true).(SemicolonTok)
		if _, ok := nextToken(false).(LBraceTok); !ok {
			check = varStmt(nextToken(true))
		}
		defer func() { _ = nextToken(true).(NewlineTok) }()
		return For{"for", []any{initial, test, check, blockStmt()}}
	default:
		defer func() { _ = nextToken(true).(NewlineTok) }()
		return varStmt(v)
	}
}

// blockStmt parses block statements that start and end with {\n ... }
// note that in LilGO opening curly braces MUST be followed by a new line
func blockStmt() any {
	_, stmts := nextToken(true).(LBraceTok), []any{}
	for nextToken(false) != RBraceTok("}") {
		stmts = append(stmts, stmt())
	}
	_ = nextToken(true).(RBraceTok)
	return stmts
}

// varStmt parses assignment statements for variables as well as expressions
func varStmt(v any) any {
	if _, ok := nextToken(false).(AssignTok); ok {
		_ = nextToken(true).(AssignTok)
		return Assign{fmt.Sprint(v), []any{expr()}}
	}
	// we have to backtrack here because the identifier that we consumed earlier is needed
	// to correctly parse the expression
	srcIdx -= len(fmt.Sprint(v))
	return expr()
}

// expr parses tokens into expression AST trees, it parses the highest priority expressions
func expr() any {
	left := sumExpr()
	switch v := nextToken(true).(type) {
	case LessTok:
		return Less{"<", []any{left, expr()}}
	case GreatTok:
		return Great{">", []any{left, expr()}}
	case EqualTok:
		return Equal{"==", []any{left, expr()}}
	case NotEqualTok:
		return NotEqual{"!=", []any{left, expr()}}
	default:
		srcIdx -= len(fmt.Sprint(v))
		return left
	}
}

// sumExpr parses addition and subtraction expressions
func sumExpr() any {
	left := primary()
	switch v := nextToken(true).(type) {
	case AddTok:
		return Add{"+", []any{left, expr()}}
	case SubTok:
		return Sub{"-", []any{left, expr()}}
	default:
		srcIdx -= len(fmt.Sprint(v))
		return left
	}
}

// primary parses the base expression types including variables, literals and paren expressions
func primary() any {
	switch v := nextToken(true).(type) {
	case VarTok:
		return Var{V: fmt.Sprint(v)}
	case Uint8Tok:
		return Uint8{V: uint8(must(strconv.Atoi(fmt.Sprint(v))))}
	case LParenTok:
		defer func() { _ = nextToken(true).(RParenTok) }()
		return expr()
	default:
		panic("syntax error!")
	}
}

// === Complier ===

// This block defines the bytecode operands for the VM
const LoadOp = byte(0x01)
const StoreOp = byte(0x02)
const PushOp = byte(0x03)
const PopOp = byte(0x04)
const AddOp = byte(0x05)
const SubOp = byte(0x06)
const LessOp = byte(0x07)
const EqualOp = byte(0x08)
const NotEqualOp = byte(0x09)
const JumpZOp = byte(0x0A)
const JumpOp = byte(0x0B)
const JumpBackOp = byte(0x0C)
const HaltOp = byte(0x0D)

// compile takes a program (which is a list of statement AST nodes) and complies them into valid bytecode
func compile(program []any) []byte {
	code := []byte{}
	for _, stmt := range program {
		switch v := stmt.(type) {
		case Var:
			code = append(code, LoadOp, byte(strings.Index(letters, v.V)))
		case Uint8:
			code = append(code, PushOp, byte(v.V))
		case Add:
			code = append(append(code, compile([]any{v.sub[0], v.sub[1]})...), AddOp)
		case Sub:
			code = append(append(code, compile([]any{v.sub[0], v.sub[1]})...), SubOp)
		case Less:
			code = append(append(code, compile([]any{v.sub[0], v.sub[1]})...), LessOp)
		case Great:
			code = append(append(code, compile([]any{v.sub[1], v.sub[0]})...), LessOp)
		case Equal:
			code = append(append(code, compile([]any{v.sub[0], v.sub[1]})...), EqualOp)
		case NotEqual:
			code = append(append(code, compile([]any{v.sub[0], v.sub[1]})...), NotEqualOp)
		case Assign:
			code = append(append(append(code, compile([]any{v.sub[0]})...), StoreOp), byte(strings.Index(letters, v.V)))
		case If:
			test, body := compile([]any{v.sub[0]}), compile(v.sub[1].([]any))
			code = append(append(append(code, test...), JumpZOp, byte(len(body))), body...)
			if len(v.sub) == 3 {
				elseBody := compile(v.sub[2].([]any))
				code[len(code)-len(body)-1] += 1
				code = append(append(code, JumpOp, byte(len(elseBody))), elseBody...)
			}
		case For:
			init, test, body := compile([]any{v.sub[0]}), compile([]any{v.sub[1]}), compile(append(v.sub[3].([]any), v.sub[2]))
			postBody := []byte{JumpBackOp, byte(2 + len(body) + len(test))}
			code = append(append(append(append(append(code, init...), test...), JumpZOp, byte(len(body)+len(postBody))), body...), postBody...)
			// There is no default section here so None{} statements are simply skipped
		}
	}
	return code
}

// === Bytecode VM ===

// run runs they bytecode provided to it. Once the VM hits a HALT instruction it will return an
// array containing the final values of all 26 variables (a-z)
func run(bytecode []byte) [26]byte {
	globals, stack, sp := [26]byte{}, [256]byte{}, byte(0)
	testOp := func(test bool) {
		if test {
			stack[sp-2] = 1
		} else {
			stack[sp-2] = 0
		}
		sp--
	}
	for pc := 1; bytecode[pc-1] != HaltOp; pc++ {
		switch bytecode[pc-1] {
		case LoadOp:
			stack[sp] = globals[bytecode[pc]]
			sp, pc = sp+1, pc+1
		case StoreOp:
			globals[bytecode[pc]] = stack[sp-1]
			pc++
		case PushOp:
			stack[sp] = bytecode[pc]
			sp, pc = sp+1, pc+1
		case AddOp:
			stack[sp-2] = stack[sp-2] + stack[sp-1]
			sp--
		case SubOp:
			stack[sp-2] = stack[sp-2] - stack[sp-1]
			sp--
		case LessOp:
			testOp(stack[sp-2] < stack[sp-1])
		case EqualOp:
			testOp(stack[sp-2] == stack[sp-1])
		case NotEqualOp:
			testOp(stack[sp-2] != stack[sp-1])
		case JumpOp:
			pc += int(bytecode[pc]) + 1
		case JumpBackOp:
			pc -= int(bytecode[pc]) + 1
		case JumpZOp:
			if stack[sp-1] == 0 {
				pc += int(bytecode[pc])
			}
			pc++
		}
	}
	return globals
}
